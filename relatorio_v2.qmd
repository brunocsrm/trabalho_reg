---
title: "Relatório"
format: pdf
editor: source
author: Tomás Bernardes & Bruno Ribeiro
---

# MUDANÇAS Q EU FIZ (OLHAR)

-   instalei o seaborn
-   e eu vou ir mudando alguns graficos pra fazer com o R mas n sei se ele vai deixar usar o ggplot msm
-   tive q tirar todas as coisas de latex pq n tava dando render no meu pc
-   enchi linguiça colocando tipo oq a gente vai analisar e os objetivos etc etc so pra ficar bonit
-   todos os bagulho q eu escrevi estao tudo errado e com erros de digitação, no final vou passar tudo por um corretor pra
ficar certinho
se vc quiser ver como fica os plots feitos no python, no R, vc tem q colocar plt.show() do pacote matplotlib.pyplot dps

os plot do python no quarto tao saindo bugado, ta saindo dois mas n sei como arruma isso, talvez tenhamos que fazer pelo ggplot mesmo.......... derrota total

# Objetivos

Este trabalho procura analisar o banco de dados *penguins* por meio de regressões lineares realizadas usando os softwares python e R.

## Breve explicação do banco de dados *penguins*

O banco de dados penguins possui a analise de três especies de penguins percentencentes ao arquipelego Palmer

```{r}
#| warning: false
#| message: false
library(palmerpenguins)
library(tidyverse)
library(reticulate)
library(gridExtra)
library(GGally)
library(reglin)
library(sjPlot)
```

```{python}
#| warning: false
import statsmodels.api as sm
import statsmodels.formula.api as smf
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
from matplotlib.gridspec import GridSpec
import plotly.express as px
from scipy.stats import shapiro, anderson, kstest
```

```{r}
dados <- penguins
dados <-  drop_na(dados)
head(penguins)
```

```{python}
#| output: false
#| warning: false
# Verificando valores nulos
dados_py = r.dados
dados_py.isnull().sum()
```

# Analise grafica

Iremos, antes de tudo, realizar uma análise exploratória dos dados para que, desta forma, possamos criar nossas primeiras hipótese. Para tal, utilizaremos o pacote **ggplot**

```{r}
#| warning: false
body_mass_plot <- ggplot(data = penguins) + #- distribution of the response variable
  aes(x = body_mass_g) +
  geom_histogram(color = "red", binwidth = 0.5) +
  xlab("Penguin body mass (g)")

species_plot <- ggplot(data = penguins) + #- distribution of the explanatory variable
  aes(x = species) +
  geom_bar(fill = "orange", binwidth = 0.5) +
  xlab("Penguin species") +
  geom_text(aes(label = ..count..), 
            stat = "count", 
            vjust = 1.5, 
            colour = "black")

bill_length_plot <- ggplot(data = penguins) + #- distribution of the explanatory variable
  aes(x = bill_length_mm) +
  geom_histogram(fill = "yellow", colour = "white", binwidth = 0.5) +
  xlab("Penguin bill length (mm)")

bill_depth_plot <- ggplot(data = penguins) + #- distribution of the explanatory variable
  aes(x = bill_depth_mm) +
  geom_histogram(fill = "green", colour = "white", binwidth = 0.5) +
  xlab("Penguin bill depth (mm)")

flipper_length_plot <- ggplot(data = penguins) + #- distribution of the explanatory variable
  aes(x = flipper_length_mm) +
  geom_histogram(fill = "blue", colour = "blue", binwidth = 0.5) +
  xlab("Penguin flipper length (mm)")

penguin_sex_plot <- ggplot(data = penguins) + #- distribution of the explanatory variable
  aes(x = sex) +
  geom_bar(fill = "purple", binwidth = 0.5) +
  xlab("Penguin sex (M of F)") +
  geom_text(aes(label = ..count..), 
            stat = "count", 
            vjust = 1.5, 
            colour = "black")
```

```{r}
#| warning: false
grid.arrange(body_mass_plot, species_plot, bill_length_plot, bill_depth_plot, flipper_length_plot, penguin_sex_plot)
```

```{r}
#| warning: false
#| message: false
ggpairs(data = penguins, mapping = aes(fill = species),
        columns = c("species", "bill_length_mm", "bill_depth_mm", "flipper_length_mm", "sex", "body_mass_g"))
```


```{python}
#| warning: false
#| message: false
fig = plt.figure(figsize=(50, 30))
gs = GridSpec(2, 3, width_ratios=[5,5,5], height_ratios=[5,5], hspace=0.5, wspace=1)

# Boxplot 1
ax1 = plt.subplot(gs[0])
sns.boxplot(x='species', y='body_mass_g', data=dados_py, palette='viridis', ax=ax1)
ax1.set(xlabel='Espécies', ylabel='Massa Corporal (g)')
ax1.set_xticklabels(ax1.get_xticklabels(), fontsize=6.3)  # Adjust x-axis label size

# Boxplot 2
ax2 = plt.subplot(gs[1])
sns.boxplot(x='island', y='body_mass_g', data=dados_py, palette='viridis', ax=ax2)
ax2.set(xlabel='Ilhas', ylabel='Massa Corporal (g)')
ax2.set_xticklabels(ax2.get_xticklabels(), fontsize=6.3)

# Boxplot 3
ax3 = plt.subplot(gs[2])
sns.boxplot(x='sex', y='body_mass_g', data=dados_py, palette='viridis', ax=ax3)
ax3.set(xlabel='Sexo', ylabel='Massa Corporal (g)')
ax3.set_xticklabels(ax3.get_xticklabels(), fontsize=6.3)

# Histogram 1
ax4 = plt.subplot(gs[3])
sns.histplot(data=dados_py, x='body_mass_g', hue='species', kde=True, palette='viridis', ax=ax4)
ax4.set(xlabel='Massa Corporal (g)', ylabel='Frequência')
ax4.legend().set_visible(False)


# Histogram 2
ax5 = plt.subplot(gs[4])
sns.histplot(data=dados_py, x='body_mass_g', hue='island', kde=True, palette='viridis', ax=ax5)
ax5.set(xlabel='Massa Corporal (g)', ylabel='Frequência')
ax5.legend().set_visible(False)

# Histogram 3
ax6 = plt.subplot(gs[5])
sns.histplot(data=dados_py, x='body_mass_g', hue='sex', kde=True, palette='viridis', ax=ax6)
ax6.set(xlabel='Massa Corporal (g)', ylabel='Frequência')
ax6.legend().set_visible(False)

plt.tight_layout()
plt.show()
```


No gráfico acima a diagonal principal fornece-nos a distribuição aproximada da variável. Acima da diagonal, temos as medidadas de correlação e abaixo dela, é mostrado o scatterplot entre duas variáveis com o intuito de observar se há correlação.

Do gráfico, é possível perceber uma forte correlação entre *body_mass* e todas as outras variaveis quantitativas, isto é, *bill_length*,*bill_depth*,**flipper_length**, o que pode causar um problema de multicolinearidade no nosso modelo.

# Hipoteses a serem testadas

Dado a primeira analise feita por meio dos graficos, iremos construir modelos analisando a variavel resposta em relação as variaveis quantitativas individualmente e simultaneamente. Esperamos que todos os parametros sejam significativos, uma vez que, quanto mais largas são as caracteristicas morfologicas do penguin, maior sera o seu peso, assim como indicado pela correlação dos gráficos anteriores.

Em seguida, iremos analisar a relação do peso dos penguins por ilhas e por especies por meio de uma modelagem paralela. Pressupomos que, nas ilhas menores, os pinguins serão mais magros, uma vez que estas podem caracer de alimento

Por fim, levaremos em conta a questão da especie diante de todas estas analises

# Seleção de de variávies

```{r}
dados <- dados %>% drop_na()
fit_null <- lm(body_mass_g ~ 1, data = dados)
fit_inter <- lm(body_mass_g ~ bill_length_mm + bill_depth_mm + flipper_length_mm, data = dados)
fit_full <- lm(body_mass_g ~ . + sex:species, data = dados)
step(
  fit_inter, 
  direction = "both", 
  scope = list(lower = fit_null, upper=fit_full)
)

```
Pela selação de variáveis, esta indicado que deveria ser incluído no modelo species, sex e year. Contudo, conforme veremos na saída 

# Analise exploratoria de alguns modelos

Primeiro, queremos verificar a a relação entre body_mass_g e bill_length_mm, bill_depth_mm e flipper_length_mm individualmente. Lembrando que estaremos testando as hipóteses

```{python}
#| output: false
dados_py = dados_py.dropna()
```

```{python}
#| output: false
dados_py.isnull().sum()
```
### *body_mass_g* vs *bill_length_mm*
```{python}
model_1 = smf.ols(formula = 'body_mass_g ~ bill_length_mm', data = dados_py)
```

```{r}
ggplot(
  dados,
  aes(x = bill_length_mm, y = body_mass_g)) +
  geom_point(aes(color = species,
                 shape = island,
                 size = sex)) +
  geom_smooth(method = "lm", se = T, color = 'darkred') +
  theme_minimal()
```
### *body_mass_g* vs *bill_depth_mm*
```{python}
model_2 = smf.ols(formula = 'body_mass_g ~ bill_depth_mm', data = dados_py)
print(model_2.fit().summary())
```

```{r}
ggplot(
  dados,
  aes(x = bill_depth_mm, y = body_mass_g)) +
  geom_point(aes(color = species,
                 shape = island,
                 size = sex)) +
  geom_smooth(method = "lm", se = T, color = 'darkred') +
  theme_minimal()
```
### *body_mass_g* vs *flipper_depth_mm*
```{python}
model_3 = smf.ols(formula = 'body_mass_g ~ flipper_length_mm', data = dados_py)
print(model_3.fit().summary())
```

```{r}
ggplot(
  dados,
  aes(x = flipper_length_mm, y = body_mass_g)) +
  geom_point(aes(color = species,
                 shape = island,
                 size = sex)) +
  geom_smooth(method = "lm", se = T, color = 'darkred') +
  theme_minimal()
```


Note que em todos os valores as variáveis são significativas, uma vez que em todos pvalor = 0 \< 0.05 e, portanto, rejeitamos a hipótese nula.
Pelos graficos percebemos duas coisas também,
* As especies dos penguins estão fortemente atreladas a ilha.
* Naturalmente, os penguins machos são mais pesados do que as femeas.
Ambas estas descobertas nos ajudarão a melhorar ainda mais o nosso modelo.

Agora, vamos tentar adicionar múltiplas variáveis independentes à fórmula

```{python}
model_4 = smf.ols(formula = 'body_mass_g ~ bill_length_mm + bill_depth_mm', data = dados_py)
print(model_4.fit().summary())
```

```{python}
model_5 = smf.ols(formula = 'body_mass_g ~ bill_length_mm + flipper_length_mm', data = dados_py)
print(model_5.fit().summary()) 
```

Note que *bill_length_mm* deu não significativo no model_5

```{python}
model_6 = smf.ols(formula = 'body_mass_g ~ bill_depth_mm + flipper_length_mm', data = dados_py)
print(model_6.fit().summary()) 
```

No modelo 6, *bill_depth_mm* deu não significativo. Agora, vamos fazer um modelo com as 3 variáveis juntas uma vez que já analisamos individualmente, dois a dois, agora faremos três a três.

```{python}
model_7 = smf.ols(formula = 'body_mass_g ~ bill_length_mm + bill_depth_mm + flipper_length_mm', data = dados_py)
print(model_7.fit().summary()) 
```

O que concluímos é que, enquanto bill_depth e bill_length são estatísticamente significativos quando usados juntos, ao serem combinados com flipper_length, eles se tornam insignificantes.

Observamos também que, pelo grafico, o tipo de especie e o sexo aparentam ter algum tipo relevancia para a regressão,o que esta de acordo com nossas suposições inciais.

```{python}
model_7 = smf.ols(formula = 'body_mass_g ~ bill_length_mm + bill_depth_mm + flipper_length_mm', data = dados_py)
print(model_7.fit().summary()) 
```

```{python}
models = [model_1, model_2, model_3, model_4, model_5, model_6, model_7]
model_summaries = pd.DataFrame({
  'Model': [f'Model {i}' for i in range(1, 8)],
  'R-squared': [model.fit().rsquared for model in models],
  'AIC': [model.fit().aic for model in models]
  
})
model_summaries
```

É possível concluir que model_3 é melhor (o que só possui o intercepto e flipper) pois nos casos em que temos flipper e bill, a segunda sempre da não significativa e caímos no modelo apenas com flipper e intercepto.

Vamos levar em conta agora as suposições descobertas pelos nosso graficos e criaremos um modelo que leva em conta dois interceptos extras, o da especie e o do sexo

```{python}
model_8 = smf.ols(formula = 'body_mass_g ~ bill_length_mm + bill_depth_mm + flipper_length_mm + species + sex', data = dados_py).fit()
print(model_8.summary()) 
```

Vemos que este modelo aparenta ser muito melhor, pois todas as variaveis demonstram ser significativas.
Compararemos agora este novo modelo com o anterioror.
```{python}
models = [model_7, model_8]
model_summaries = pd.DataFrame({
  'Model': [f'Model {i}' for i in range(7, 9)],
  'R-squared': [model.fit().rsquared for model in models],
  'AIC': [model.fit().aic for model in models]
  
})
model_summaries
```
Concluimos, portanto, que o o ultimo modelo demonstra ser melhor que todos os outros, ja que seu R2 é maior e o seu AIC menor, ou seja, ele explica uma porcentagem maior da variavel resposta do que os outros modelos.

Num primeiro momento, parece razoável considerar a inclusão de variaveis com interação para este modelo. No entanto, os resultados abaixo evidenciam que essa suposição se mostra pouco apropriada para o nosso estudo. 

Note que a Sepecie Adelia bem como o sexo Feminino foram removidos pelo fato de serem insignificantes.

```{python}
model_9 = smf.ols(formula = 'body_mass_g ~ bill_length_mm + bill_depth_mm + flipper_length_mm + species + sex + species:bill_length_mm + species:bill_depth_mm  + species:flipper_length_mm', data = dados_py)
print(model_9.fit().summary()) 
```

Vemos que este modelo não aparenta ser muito bom, pois tem muitas variaveis e poucas delas relevantes para o modelo

Isso se deve, possivelmente, porque o ganho de peso nas diferentes espécies de pinguins segue um padrão similar em relação ao aumento das características morfológicas que estamos analisando.

Em contraste com os resultados anteriores, vemos que a interação com a varivel sexo, de fato, proporciona um modelo ligeiramente supeior. Com isso, portanto, nota-se que o melhor modelo é o que contém apenas a interação entre sexo e espécie

```{python}
model_10 = smf.ols(formula = 'body_mass_g ~ bill_length_mm + bill_depth_mm + flipper_length_mm + species + sex + sex:bill_length_mm + sex:bill_depth_mm  + sex:flipper_length_mm', data = dados_py).fit()
print(model_10.summary()) 
```

```{python}
models = [model_8, model_9,model_10]
model_summaries = pd.DataFrame({
  'Model': [f'Model {i}' for i in range(8, 11)],
  'R-squared': [model.fit().rsquared for model in models],
  'AIC': [model.fit().aic for model in models]
  
})
model_summaries
```
Contudo, apesar da breve porem existente superioridade do modelo 10, o modelo 8 ainda demonstra ser preferivel, ja que consegue explicar os dados de forma bastante similar mas operando com muito menos variaveis.

# Verificação de adequação do modelo

Iremos agora fazer a analise de residuos do modelo que escolhemos o modelo 8. 

```{r}
fit_8 <- lm(body_mass_g ~ bill_length_mm + bill_length_mm + flipper_length_mm + species + sex, data = dados)
ggresiduals(fit_8)
```


Conforme podemos observar no gráfico acima, o modelo 8 satisfaz a suposição de hocedasticidade bem como a de normalidade. Além disso, não há nenhum problema de escala entre as covariáveis e, não há valores outliers, apenas alguns pontos de alavanca e outros influentes.


```{python}

residuals = model_8.resid

shapiro_test_stat, shapiro_p_value = shapiro(residuals)
anderson_test_stat, anderson_critical_values, anderson_significance_levels = anderson(residuals)
ks_test_stat, ks_p_value = kstest(residuals, 'norm')


normality_test_results = pd.DataFrame({
    'Test': ['Shapiro-Wilk', 'Anderson-Darling', 'Kolmogorov-Smirnov'],
    'Test Statistic': [shapiro_test_stat, anderson_test_stat, ks_test_stat],
    'p-value': [shapiro_p_value, None, ks_p_value]  # Anderson-Darling has critical values and significance levels
})


print(normality_test_results)
```
Todos os testes de normalidade, concluem que os resíduos são normais.

Agora, prosseguimos para a multicolinearidade

```{python}
from statsmodels.stats.outliers_influence import variance_inflation_factor

vif= pd.DataFrame()
vif["Covariável"] = X.columns
vif["VIF"] = [variance_inflation_factor(model_10.model.data.orig_exog.values, i) for i in range(X.shape[1])]

print(vif)
```

Conforme podemos ver na tabela acima, o modelo possui problemas de multicolinearidade para as variáveis intercepto, Gentoo, sexo masculino, profundidade do bico e comprimento da asa.















